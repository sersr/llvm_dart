import "std:d.kc";
import "std:allocator.kc";

fn main() i32 {

  let foo = Box.new( 101 );

  let bar = foo;
  let y = 100;

  let bbs = BBs{b: 1001, s: foo };
  let bbc = BBs{b: 1001, s: bar };

  let fbar = Box.new( 202 );
  bbs.s = fbar;

  fbar = foo; // drop fbar
  foo = fbar; // ??? foo == fbar
  
  
  // bbc = bbs;
  bbs = bbc; // drop bbs.s -> fbar 

  let size = foo.getSize();
  printf("size: %d\n", size);

  // bbs = bbc; drop bbs.s -> fbar
  0;
}

struct BBs<T> {
  b: i64,
  s: Box<T>,
}


struct Box<T: i32,S: Stack + Copy> {
  ptr: *BoxData<T>,
}

struct BoxData<T> {
  size: usize,
  data: T,
}

impl Box<T> {
  static fn new(data: T) Self {
    final ptr = malloc(sizeOf(BoxData<T>)) as *BoxData<T>;
    ptr.data = data;
    ptr.size = 1;
    return Box { ptr };
  }

  fn getValue() &T {
    &self.ptr.data;
  }

  fn getSize() usize {
    self.ptr.size;
  }
}

impl Stack for Box<i32> {
  fn addStack() {
    self.ptr.size += 1;
    printf("add    box: %d, %d\n", *self.getValue(), self.getSize());
  }
  
  fn removeStack() {
    self.ptr.size -= 1;
    printf("remove box: %d, %d\n",  self.ptr.data, self.ptr.size);
    if self.ptr.size <= 0 {
      free(self.ptr);
    }
  }
}
