
fn main() i32 {  
  let value = 1001;
  
  fn catch_value() {
    printf("hello catch: %d\n", value);
  }
  
  let y = 222; 
  
  fn catchy() {
    printf("hello catch: y %d %d\n", y, value);
  }
  
  test_closure(catch_value);
  test_closure(catchy);

  test_catch(catch_value);
  test_catch(catchy);

  let y = test_main();
  y();

  catch_value();
  wrap(catch_value);

  let h = HA{11,22};
  par_ha(h);
  printf("ha: %d, %d\n", h.y,h.x);
  0;
}

fn wrap<F: fn()>(f: F) {
  f();
}

struct HA {
  y: i64,
  x: i64,
}

fn par_ha(ha: HA) {
  printf("ha: %d, %d\n", ha.y,ha.x);
  ha.y = 555;
  ha.x = 32;
}

fn ret_ha() HA {
  return HA{110, 111};
}

fn test_closure<F: dyn fn()>(f: F) {
  f();
}

fn test_catch<F: fn()>(f: F) {
  f();
}

fn test_main() dyn fn() {
  printf("hello\n");

  fn hello() {
    printf("hello closure.\n");
  }

  hello;
}

struct DynFn {
  addr: *void,
  catch: *void,
}

struct He{
  y: Option<&He>,
}