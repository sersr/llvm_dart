import 'd.kc';

struct Gen {
    y: i32,
    s: string,
}

com Print {
  fn printx();
}

impl Print:test for Gen {
  fn printx() {
    print(self.s);
	}
}

fn hello<T>(y: &T) {
  y.printx();
}

fn main() i32 {
  let g = Gen { 10 , &"hello"};
 hello(&g);

 let gg = g;

  let hh = hello<Gen>;
  hh(&g);
  let t = ttt;
  t(&g);

  let yaa = g.hh().hh();
  printf("yaa: %d\n", yaa.y);
  let x =  Gen {3};
  let xx = x.xxx();

  init_sig_stack();
  print("end");
  0;
}

fn ttt(y: &Gen) {
  print('base');
}

impl Gen {

  fn hh() &Gen {
    print('hh');
    &self
  }

  fn drop() {
    print("gen drop");
  }

  fn xxx() &i32 {
    let y = 100;
    &y;
  }
}

impl i32 {
  fn drop() {
    print("i32 drop");
  }
}

type voidPtr;

extern
struct stack_t {
  ss_sp : voidPtr,
  ss_size: i64,
  ss_flags: i32,
}

fn init_sig_stack() {
  let ss = stack_t {};
    let addr = mmap(NULL, 131072, 3,4097, -1, 0);
  ss.ss_sp = addr;
  ss.ss_flags = 0;
  ss.ss_size = 131072;
  let y = sigaltstack(&ss, NULL);

  
  let sig = sigactionc {};
  let yya = sig.sa_sigaction;
  sig.sa_sigaction = sig_handler;
  sig.sa_flags = 1;
  sig.sa_mask = 11;
  sigemptyset(&sig.sa_mask);
  printf("mask%d\n", sig.sa_mask);
  printf("prt: %d, %p, %p\n", yya, sig.sa_sigaction,sig_handler);

  let result = sigaction(11, &sig, NULL);
  printf("result: %d\n", result);
  loopx();
}

extern
fn exit(code: i32);

extern
fn sigemptyset(mask: &u32);

extern
fn sigaction(sig: i32, sa: &sigactionc, oss: voidPtr) i32;
fn loopx() {
  loopx();
}

extern 
fn sig_handler(sig: i32) {
  printf("sig %d\n", sig);
  // todo: call munmap
  // 
  exit(1);
}

extern
struct sigactionc {
  sa_sigaction: voidPtr,
  sa_mask: u32,
  sa_flags: i32,
}

extern fn sigaltstack(t: &stack_t, oss: &stack_t) i32;

extern fn mmap(addr: voidPtr, size: usize, p: i32,pp: i32,  f: i32, offset: i64) voidPtr;
extern fn munmap(addr: voidPtr, size: usize);