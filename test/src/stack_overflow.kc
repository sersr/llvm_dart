
import 'd.kc';

type voidPtr;
extern
struct stack_t {
  ss_sp : voidPtr,
  ss_size: i64,
  ss_flags: i32,
}

fn init_sig_stack() {
  let ss = stack_t {};
    let addr = mmap(null, 131072, 3,4097, -1, 0);
  ss.ss_sp = addr;
  ss.ss_flags = 0;
  ss.ss_size = 131072;
  let y = sigaltstack(&ss, null);
  sig_data = addr;
  
  let sig = sigactionc {};
  let yya = sig.sa_sigaction;
  sig.sa_sigaction = sig_handler;
  sig.sa_flags = 1;
  sig.sa_mask = 11;
  sigemptyset(&sig.sa_mask);
  printf("sa_mask: %d\n", sig.sa_mask);
  printf("ss_sp: %d, %p, %p\n", yya, sig.sa_sigaction,sig_handler);

  let result = sigaction(11, &sig, null);
  printf("result: %d\n", result);
}

extern
fn exit(code: i32);

extern
fn sigemptyset(mask: &u32);

static sig_data:voidPtr = null;
extern
fn sigaction(sig: i32, sa: &sigactionc, oss: voidPtr) i32;

extern 
fn sig_handler(sig: i32) {
  printf("sig %d\n", sig);

  exit(1);

}

fn drop_handler() {
  let y =stack_t {};
  y.ss_flags = 4;
  y.ss_sp = null;
  y.ss_size = 131072;

  sigaltstack(&y, null);
  munmap(sig_data, 131072);
}

extern
struct sigactionc {
  sa_sigaction: voidPtr,
  sa_mask: u32,
  sa_flags: i32,
}

extern fn sigaltstack(t: &stack_t, oss: &stack_t) i32;

extern fn mmap(addr: voidPtr, size: usize, p: i32,pp: i32,  f: i32, offset: i64) voidPtr;
extern fn munmap(addr: voidPtr, size: usize);